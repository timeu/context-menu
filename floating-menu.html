<link rel="import" href="floating-menu-veil.html">
<link rel="import" href="floating-submenu.html">
<link rel="import" href="floating-menu-item.html">

<!--
Custom element providing a floating menu with a simple API. It is designed and polished for fast and simple user experience on both desktop and mobile.

##### Examples

    <floating-menu options="{{menuOptions}}"></floating-menu>

    <floating-menu>
      <floating-menu-item label="HTML Item">
        <floating-menu-item label="HTML Subitem1" action="console.log" arguments="1"></floating-menu-item>
        <floating-menu-item label="HTML Subitem2" action="console.log" arguments="2"></floating-menu-item>
        <floating-menu-item label="HTML Subitem3">
          <floating-menu-item label="HTML Subitem4"></floating-menu-item>
        </floating-menu-item>
      </floating-menu-item>
    </floating-menu>

##### [Live Demo](http://aleksandarrodic.com/floating-menu/)

##### Features

- Simple API
- Touch support
- Smart hover-handling (requires less user precision)
- Window edge detection (menu position adjusted when too close to the edge)

##### Motivation

Floating menus are very simple to make with just a bit of HTML, JavaScript and CSS. However, most implementations don't work quite right when it comes to touch support, and user experience can be quite bad if a user has limited screen space or clumsy hands. In this implementation, I attempted to correct some of those problems and and package it in a reusable component.

@element floating-menu
@blurb Custom element providing a floating menu with a simple API
@status alpha
@url https://github.com/arodic/floating-menu
-->

<polymer-element name="floating-menu" attributes="options">
  <template>
    <link href="floating-menu.css" rel="stylesheet" type="text/css" />
    <floating-submenu id="submenu" root="{{}}" expanded="{{expanded}}" options="{{options}}">
      <content></content>
    </floating-submenu>
  </template>
  <script>
  (function() {

    var HOLD_TIME = 250;
    var MARGIN = 8;
    var timeout;

    Polymer('floating-menu', {

      /**
       * The `floating-menu-expanded` event fires when the menu is expanded.
       * 
       * @event floating-menu-expanded
       */

      /**
       * The `floating-menu-collapsed` event fires when the menu is collapsed.
       * 
       * @event floating-menu-collapsed
       */

      /**
       * The `options` attribute is a list of item objects.
       * { label: "option", action: function(){}, arguments: [], options: [] }

       * @attribute options
       * @type list of objects
       */
      options: undefined,
      ready: function() {
        var scope = this;

        this.expanded = false;

        this.setAttribute( 'oncontextmenu', 'return false');

        this.collapse = function(event) {
          event.preventDefault();
          event.stopPropagation();
          scope.expanded = false;
          Platform.flush();
        };
        this.collapseLater = function(event) {
          event.preventDefault();
          event.stopPropagation();
          timeout = setTimeout(function(){
            scope.expanded = false;
          }, HOLD_TIME);
        };
        this.cancelCollapse = function (event) {
          event.preventDefault();
          event.stopPropagation();
          clearTimeout(timeout);
        };
        this.expand = function(event) {
          event.preventDefault();
          event.stopPropagation();
          scope.expanded = true;
          scope.style.top = event.clientY - 8 + "px";
          scope.style.left = event.clientX - 8 + "px";
          clearTimeout(timeout);
          Platform.flush();
          scope.getItems();
        };

        this.pointerVelocity = 0;
        var x = 0, y = 0, tempV;
        this.updatePointerVelocity = function(event) {
          event.preventDefault();
          event.stopPropagation();
          if (event.changedTouches) event = event.changedTouches[0];
          tempV = Math.abs(event.pageY - y)/2 - (event.pageX - x);
          this.pointerVelocity = tempV;
          x = event.pageX;
          y = event.pageY;
        };

        this._itemsMatrix = [];
        this.traverseItems = function ( submenu, depth ) {
          if (!scope._itemsMatrix[depth]) scope._itemsMatrix[depth] = [];
          for (var i = submenu.items.length; i--;) {
            scope._itemsMatrix[depth].push(submenu.items[i]);
            scope.traverseItems(submenu.items[i].$.submenu, depth + 1);
          }
        };
        this.getItems = function(){
          scope._itemsMatrix.length = 0;
          scope.traverseItems(scope.$.submenu, 0);
        };

        var expandTimeout = {};
        this._currentDepth = -1;
        this.hover = function(event){
          clearTimeout(expandTimeout);
          event.preventDefault();
          event.stopPropagation();

          if (event.changedTouches) event = event.changedTouches[0];
          var x = event.pageX - window.scrollX;
          var y = event.pageY - window.scrollY;
          
          for (var i = scope._itemsMatrix.length; i--;){
            for (var j = scope._itemsMatrix[i].length; j--;){
  
              if(scope._itemsMatrix[i][j].listen){
                if (
                  scope._itemsMatrix[i][j].rect.left <= x &&
                  (scope._itemsMatrix[i][j].rect.left + scope._itemsMatrix[i][j].rect.width) >= x &&
                  scope._itemsMatrix[i][j].rect.top <= y &&
                  (scope._itemsMatrix[i][j].rect.top + scope._itemsMatrix[i][j].rect.height) >= y
                ) {
                  if (scope.pointerVelocity > 0 || scope._currentDepth != i){
                    scope._itemsMatrix[i][j].expanded = true;
                    Platform.flush();
                  } else {
                    expandTimeout = setTimeout(function(){
                      scope._itemsMatrix[i][j].expanded = true;
                    }, HOLD_TIME);
                  }
                  
                  scope._currentDepth = i;
                  return;
                }
              }
            }  
          }

          scope._currentDepth = -1;
        };

        this.veil = document.querySelector('#floating-menu-veil');     
      },
      attached: function() {
        this._parentNode = this.parentNode;
        this._parentNode.addEventListener('contextmenu', this.expand);
      },
      detached: function(event) {
        this._parentNode.removeEventListener('contextmenu', this.expand);
      },
      expandedChanged: function() {
        this.classList.toggle('expanded', this.expanded);
        if (this.expanded) {
          this.veil.addEventListener('mouseover', this.collapseLater);
          this.veil.addEventListener('mousedown', this.collapse);
          this.veil.addEventListener('touchstart', this.collapse);
          window.addEventListener('scroll', this.collapse);
          this.addEventListener('floating-menu-action-fired', this.collapse);
          //
          this.addEventListener('mousemove', this.cancelCollapse);
          this.addEventListener('touchmove', this.cancelCollapse);
          //
          this.addEventListener('mousemove', this.updatePointerVelocity);
          this.addEventListener('touchmove', this.updatePointerVelocity);
          //
          this.addEventListener('mousemove', this.hover);
          this.addEventListener('touchmove', this.hover);
          this.addEventListener('touchstart', this.hover);
          //
          this.fire('floating-menu-expanded', this);
        } else {
          this.veil.removeEventListener('mouseover', this.collapseLater);
          this.veil.removeEventListener('mousedown', this.collapse);
          this.veil.removeEventListener('touchstart', this.collapse);
          window.removeEventListener('scroll', this.collapse);
          this.removeEventListener('floating-menu-action-fired', this.collapse);
          //
          this.removeEventListener('mousemove', this.cancelCollapse);
          this.removeEventListener('touchmove', this.cancelCollapse);
          //
          this.removeEventListener('mousemove', this.updatePointerVelocity);
          this.removeEventListener('touchmove', this.updatePointerVelocity);
          //
          this.removeEventListener('mousemove', this.hover);
          this.removeEventListener('touchmove', this.hover);
          this.removeEventListener('touchstart', this.hover);          
          //
          this.fire('floating-menu-collapsed', this);
        }
      }
    });

  })();
  </script>
</polymer-element>