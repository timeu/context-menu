<polymer-element name="floating-menu-veil" assetpath="../">
  <template>
    <style type="text/css">:host {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
  z-index: 999999;
  cursor: default;
  /*background: black;*/
  /*opacity: 0.25;*/
}
:host(.visible) {
  display: block;
}</style>
  </template>
  <script>
  (function(){
    var veil = document.createElement('floating-menu-veil');
    veil.id = 'floating-menu-veil';
    document.body.appendChild(veil);
    Polymer('floating-menu-veil', {
      ready: function() {
        var scope = this;
        this.setAttribute( 'oncontextmenu', 'return false');
        window.addEventListener('floating-menu-expanded', function(){
          scope.classList.toggle('visible', true);
        });
        window.addEventListener('floating-menu-collapsed', function(){
          scope.classList.toggle('visible', false);
        });
      }
    });
  })();
  </script>
</polymer-element>
<polymer-element name="floating-submenu" attributes="root expanded options" assetpath="../">
  <template>
    <style type="text/css">:host {
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  box-sizing: border-box;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  -ms-box-sizing: border-box;
  -webkit-transform: translate3d(0,0,0);
  -moz-transform: translate3d(0,0,0);
  -ms-transform: translate3d(0,0,0);
  -o-transform: translate3d(0,0,0);
  transform: translate3d(0,0,0);
  display: none;
  position: absolute;
  z-index: 1000001;
  top:0;
  left: 0;
  min-width: 80px;
  border: 1px solid rgba(255, 255, 255, 0.25);
  padding: 4px 0;
  border-radius: 2px;
  background: #666;
  box-shadow: -2px 2px 10px rgba(0, 0, 0, 0.5);
}

:host(.expanded:not(.empty)) {
  display: block;
}</style>
    <template repeat="{{option in options}}">
      <floating-menu-item id="item" root="{{root}}" label="{{option.label}}" action="{{option.action}}" arguments="{{option.arguments}}" options="{{option.options}}">
      </floating-menu-item>
    </template>
    <content></content>
  </template>
  <script>
  (function() {

    var HOLD_TIME = 250;
    var MARGIN = 8;
    
    Polymer('floating-submenu', {
      top: 0,
      left: 0,
      offset: 0,
      expanded: false,
      ready: function() {
        var scope = this;

        this.nudge = function() {
          // nudge up
          var bottomDist = (this.rect.bottom - this.top + MARGIN) - window.innerHeight;
          if (bottomDist > 0) this.top = - bottomDist;
          else this.top = 0;
          // nudge left
          var rightDist = (this.rect.right - this.left + MARGIN) - window.innerWidth;
          if (rightDist > 0 && this.offset === 0) this.left = - rightDist;
          else if (rightDist > - this.offset) this.left = - this.rect.width;
          else this.left = this.offset;
        };

        this.resetItems = function() {
          for (var i = this.items.length; i--;){
            this.items[i].expanded = false;
            this.items[i].update();
          }
        };

        this.addEventListener('floating-submenu-expanded', function(event){
          scope.rect = scope.getBoundingClientRect();
          if (scope == event.detail) {
            event.detail.nudge();
            return;
          }
          event.stopPropagation();
          event.detail.offset = scope.rect.width - 1;
          event.detail.nudge();
          this.rect = this.getBoundingClientRect();
        });

        scope.items = [];
        this.addEventListener('floating-menu-item-attached', function(event){
          event.stopPropagation();
          scope.items.push(event.detail);
          event.detail.bind('root', new PathObserver(scope, 'root'));
          event.detail.bind('listen', new PathObserver(scope, 'expanded'));
        });

        this.addEventListener('floating-item-expanded', function(event){
          event.stopPropagation();
          // unexpand all except the one just expanded
          for (var i = this.items.length; i--;){
            if (this.items[i] != event.detail) {
              this.items[i].expanded = false;
            }
          }
        });

      },
      expandedChanged: function() {
        this.classList.toggle('expanded', this.expanded);
        this.classList.toggle('empty', this.items.length === 0);

        if (this.expanded) {
          this.resetItems();
          this.fire('floating-submenu-expanded', this);
        } else {
          this.fire('floating-submenu-collapsed', this);
        }
      },
      topChanged: function() {
        this.style.top = this.top + 'px';
      },
      leftChanged: function() {
        this.style.left = this.left + 'px';
      }
    });
  })();
  </script>
</polymer-element>
<polymer-element name="floating-menu-item" attributes="root label listen empty action arguments expanded options" assetpath="../">
  <template>
    <style type="text/css">:host {
  position: relative;
  display: block;
  cursor: pointer;
  min-width: 80px;
  padding: 2px 9px;
  border-radius: 1px;
  color: #ccc;
}
:host(:not(.active)) {
  opacity: 0.25;
}
:host(.expanded) {
  background: #69F;
  color: #fff;
}</style>
    <floating-submenu id="submenu" root="{{root}}" options="{{options}}" expanded="{{expanded}}"><content></content></floating-submenu>
    &nbsp;{{label}}&nbsp;
  </template>
  <script>
  (function() {

    var MARGIN = 8;

    function invokeFunction(obj, path, args) {
      var idx = path.indexOf('.');
      if (idx < 0) {
        obj[path].apply(obj, args);
        return;
      }
      var first = path.substring(0,idx);
      var rest = path.substring(idx+1);
      invokeFunction(obj[first], rest, args);
    }

    Polymer('floating-menu-item', {
      label: '',
      action: undefined,
      arguments: undefined,
      expanded: false,
      options: [],
      ready: function() {
        var scope = this;

        this.fireAction = function(event) {
          event.preventDefault();
          event.stopPropagation();
          var args = scope.arguments;
          var action = scope.action;

          if (typeof args == 'string') args = args.split(' ');
          if (!args instanceof Array) args = [args];

          if (typeof action == 'function') action.apply(null, args);
          if (typeof action == 'string') action = invokeFunction(window, action, args);

          this.fire('floating-menu-action-fired', this);
        };
      },
      attached: function() {
        this.fire('floating-menu-item-attached', this);
      },
      detached: function() {
        this.fire('floating-menu-item-detached', this);
      },
      update: function() {
        var scope = this;
        this.classList.toggle('active', this.action || this.options.length || this.$.submenu.items.length);
        setTimeout(function(){scope.rect = scope.getBoundingClientRect();},1);
      },
      listenChanged: function() {
        this.update();
        if (this.listen) {
          if (this.action || this.$.submenu.items.length === 0) {
            this.addEventListener('click', this.fireAction);
            this.addEventListener('touchend', this.fireAction);
          }
        } else {
          this.removeEventListener('click', this.fireAction);
          this.removeEventListener('touchend', this.fireAction);
        }
      },
      expandedChanged: function() {
        this.classList.toggle('expanded', this.expanded);
        if (this.expanded) {
          this.fire('floating-item-expanded', this);
        } else {
          this.fire('floating-item-collapsed', this);
        }
      }
    });

  })();
  </script>
<!-- </polymer-element> --></polymer-element>

<!--
Custom element providing a floating menu with a simple API. It is designed and polished for fast and simple user experience on both desktop and mobile.

##### Examples

    <floating-menu options="{{menuOptions}}"></floating-menu>

    <floating-menu>
      <floating-menu-item label="HTML Item">
        <floating-menu-item label="HTML Subitem1" action="console.log" arguments="1"></floating-menu-item>
        <floating-menu-item label="HTML Subitem2" action="console.log" arguments="2"></floating-menu-item>
        <floating-menu-item label="HTML Subitem3">
          <floating-menu-item label="HTML Subitem4"></floating-menu-item>
        </floating-menu-item>
      </floating-menu-item>
    </floating-menu>

##### [Live Demo](http://aleksandarrodic.com/floating-menu/)

##### Features

- Simple API
- Touch support
- Smart hover-handling (requires less user precision)
- Window edge detection (menu position adjusted when too close to the edge)

##### Motivation

Floating menus are very simple to make with just a bit of HTML, JavaScript and CSS. However, most implementations don't work quite right when it comes to touch support, and user experience can be quite bad if a user has limited screen space or clumsy hands. In this implementation, I attempted to correct some of those problems and and package it in a reusable component.

@element floating-menu
@blurb Custom element providing a floating menu with a simple API
@status alpha
@url https://github.com/arodic/floating-menu
-->

<polymer-element name="floating-menu" attributes="options" assetpath="../">
  <template>
    <style type="text/css">:host {
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  white-space:nowrap;
  font-family: 'Open Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;
  font-size: 13px;
  color: white;
  visibility: hidden;
  position: fixed;
  z-index: 1000000;
  background: red;
  cursor: default;
}
:host(.expanded) {
  visibility: visible;
}</style>
    <floating-submenu id="submenu" root="{{}}" expanded="{{expanded}}" options="{{options}}">
      <content></content>
    </floating-submenu>
  </template>
  <script>
  (function() {

    var HOLD_TIME = 250;
    var MARGIN = 8;
    var timeout;

    Polymer('floating-menu', {

      /**
       * The `floating-menu-expanded` event fires when the menu is expanded.
       * 
       * @event floating-menu-expanded
       */

      /**
       * The `floating-menu-collapsed` event fires when the menu is collapsed.
       * 
       * @event floating-menu-collapsed
       */

      /**
       * The `options` attribute is a list of item objects.
       * { label: "option", action: function(){}, arguments: [], options: [] }

       * @attribute options
       * @type list of objects
       */
      options: undefined,
      ready: function() {
        var scope = this;

        this.expanded = false;

        this.setAttribute( 'oncontextmenu', 'return false');

        this.collapse = function(event) {
          event.preventDefault();
          event.stopPropagation();
          scope.expanded = false;
          Platform.flush();
        };
        this.collapseLater = function(event) {
          event.preventDefault();
          event.stopPropagation();
          timeout = setTimeout(function(){
            scope.expanded = false;
          }, HOLD_TIME);
        };
        this.cancelCollapse = function (event) {
          event.preventDefault();
          event.stopPropagation();
          clearTimeout(timeout);
        };
        this.expand = function(event) {
          event.preventDefault();
          event.stopPropagation();
          scope.expanded = true;
          scope.style.top = event.clientY - 8 + "px";
          scope.style.left = event.clientX - 8 + "px";
          clearTimeout(timeout);
          Platform.flush();
          scope.getItems();
        };

        this.pointerVelocity = 0;
        var x = 0, y = 0, tempV;
        this.updatePointerVelocity = function(event) {
          event.preventDefault();
          event.stopPropagation();
          if (event.changedTouches) event = event.changedTouches[0];
          tempV = Math.abs(event.pageY - y)/2 - (event.pageX - x);
          this.pointerVelocity = tempV;
          x = event.pageX;
          y = event.pageY;
        };

        this._itemsMatrix = [];
        this.traverseItems = function ( submenu, depth ) {
          if (!scope._itemsMatrix[depth]) scope._itemsMatrix[depth] = [];
          for (var i = submenu.items.length; i--;) {
            scope._itemsMatrix[depth].push(submenu.items[i]);
            scope.traverseItems(submenu.items[i].$.submenu, depth + 1);
          }
        };
        this.getItems = function(){
          scope._itemsMatrix.length = 0;
          scope.traverseItems(scope.$.submenu, 0);
        };

        var expandTimeout = {};
        this._currentDepth = -1;
        this.hover = function(event){
          clearTimeout(expandTimeout);
          event.preventDefault();
          event.stopPropagation();

          if (event.changedTouches) event = event.changedTouches[0];
          var x = event.pageX - window.scrollX;
          var y = event.pageY - window.scrollY;
          
          for (var i = scope._itemsMatrix.length; i--;){
            for (var j = scope._itemsMatrix[i].length; j--;){
  
              if(scope._itemsMatrix[i][j].listen){
                if (
                  scope._itemsMatrix[i][j].rect.left <= x &&
                  (scope._itemsMatrix[i][j].rect.left + scope._itemsMatrix[i][j].rect.width) >= x &&
                  scope._itemsMatrix[i][j].rect.top <= y &&
                  (scope._itemsMatrix[i][j].rect.top + scope._itemsMatrix[i][j].rect.height) >= y
                ) {
                  if (scope.pointerVelocity > 0 || scope._currentDepth != i){
                    scope._itemsMatrix[i][j].expanded = true;
                    Platform.flush();
                  } else {
                    expandTimeout = setTimeout(function(){
                      scope._itemsMatrix[i][j].expanded = true;
                    }, HOLD_TIME);
                  }
                  
                  scope._currentDepth = i;
                  return;
                }
              }
            }  
          }

          scope._currentDepth = -1;
        };

        this.veil = document.querySelector('#floating-menu-veil');     
      },
      attached: function() {
        this._parentNode = this.parentNode;
        this._parentNode.addEventListener('contextmenu', this.expand);
      },
      detached: function(event) {
        this._parentNode.removeEventListener('contextmenu', this.expand);
      },
      expandedChanged: function() {
        this.classList.toggle('expanded', this.expanded);
        if (this.expanded) {
          this.veil.addEventListener('mouseover', this.collapseLater);
          this.veil.addEventListener('mousedown', this.collapse);
          this.veil.addEventListener('touchstart', this.collapse);
          window.addEventListener('scroll', this.collapse);
          this.addEventListener('floating-menu-action-fired', this.collapse);
          //
          this.addEventListener('mousemove', this.cancelCollapse);
          this.addEventListener('touchmove', this.cancelCollapse);
          //
          this.addEventListener('mousemove', this.updatePointerVelocity);
          this.addEventListener('touchmove', this.updatePointerVelocity);
          //
          this.addEventListener('mousemove', this.hover);
          this.addEventListener('touchmove', this.hover);
          this.addEventListener('touchstart', this.hover);
          //
          this.fire('floating-menu-expanded', this);
        } else {
          this.veil.removeEventListener('mouseover', this.collapseLater);
          this.veil.removeEventListener('mousedown', this.collapse);
          this.veil.removeEventListener('touchstart', this.collapse);
          window.removeEventListener('scroll', this.collapse);
          this.removeEventListener('floating-menu-action-fired', this.collapse);
          //
          this.removeEventListener('mousemove', this.cancelCollapse);
          this.removeEventListener('touchmove', this.cancelCollapse);
          //
          this.removeEventListener('mousemove', this.updatePointerVelocity);
          this.removeEventListener('touchmove', this.updatePointerVelocity);
          //
          this.removeEventListener('mousemove', this.hover);
          this.removeEventListener('touchmove', this.hover);
          this.removeEventListener('touchstart', this.hover);          
          //
          this.fire('floating-menu-collapsed', this);
        }
      }
    });

  })();
  </script>
</polymer-element>